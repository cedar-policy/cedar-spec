use libfuzzer_sys::arbitrary;

/// Our Error type, which carries somewhat more information than
/// `arbitrary::Error`, for the purposes of debugging and metrics
#[derive(Debug)]
pub enum Error {
    /// Like `NotEnoughData` in `arbitrary::Error`, this represents that we ran
    /// out of bytes in the `Unstructured`
    NotEnoughData,
    /// Like `EmptyChoose` in `arbitrary::Error`, this represents that we tried
    /// to `.choose()` (or equivalent) on an empty slice
    EmptyChoose {
        /// short string describing what we were doing when this happened
        doing_what: &'static str,
    },
    /// Tried to generate an expression deeper than allowed, and couldn't
    /// recover by putting some depth-0 expression in the leaf
    TooDeep,
    /// Generated schema ended up with no valid principal types, no valid
    /// resource types, or both
    NoValidPrincipalOrResourceTypes,
    /// Tried to generate something with an extension type, but extension types
    /// were disabled in settings
    ExtensionsDisabled,
    /// Tried to generate something using the `like` operator, but the `like`
    /// operator was disabled in settings
    LikeDisabled,
    /// `IncorrectFormat` error that was generated by the `arbitrary` crate directly.
    /// We try to maintain the invariant that we don't generate these ourselves,
    /// preferring the more specific errors above
    IncorrectFormat {
        /// short string describing what we were doing when this happened
        doing_what: &'static str,
    },
    /// Error generated by the `arbitrary` crate, other than the three in
    /// `arbitrary::Error` as of this writing. This is necessary because
    /// `arbitrary::Error` is marked non-exhaustive. We don't generate these
    /// ourselves.
    OtherArbitrary(arbitrary::Error),
}

/// Type alias for convenience
pub type Result<T> = std::result::Result<T, Error>;

impl From<Error> for arbitrary::Error {
    fn from(e: Error) -> arbitrary::Error {
        match e {
            Error::NotEnoughData => arbitrary::Error::NotEnoughData,
            Error::EmptyChoose { .. } => arbitrary::Error::EmptyChoose,
            Error::TooDeep => arbitrary::Error::IncorrectFormat,
            Error::NoValidPrincipalOrResourceTypes => arbitrary::Error::IncorrectFormat,
            Error::ExtensionsDisabled => arbitrary::Error::IncorrectFormat,
            Error::LikeDisabled => arbitrary::Error::IncorrectFormat,
            Error::IncorrectFormat { .. } => arbitrary::Error::IncorrectFormat,
            Error::OtherArbitrary(e) => e,
        }
    }
}

impl From<arbitrary::Error> for Error {
    fn from(e: arbitrary::Error) -> Error {
        match e {
            arbitrary::Error::NotEnoughData => Error::NotEnoughData,
            arbitrary::Error::EmptyChoose => Error::EmptyChoose { doing_what: "" },
            arbitrary::Error::IncorrectFormat => Error::IncorrectFormat { doing_what: "" },
            e => Error::OtherArbitrary(e),
        }
    }
}

/// Apply this to an `arbitrary::Error` to get an `Error` with a more
/// informative `doing_what` in the EmptyChoose or IncorrectFormat cases
pub fn while_doing(what: &'static str, e: arbitrary::Error) -> Error {
    match e {
        arbitrary::Error::EmptyChoose => Error::EmptyChoose { doing_what: what },
        arbitrary::Error::IncorrectFormat => Error::IncorrectFormat { doing_what: what },
        e => e.into(),
    }
}
