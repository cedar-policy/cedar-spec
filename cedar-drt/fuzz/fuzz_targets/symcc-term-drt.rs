/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#![no_main]
use cedar_drt::logger::initialize_log;
use cedar_drt_inner::{fuzz_target, symcc::SinglePolicyFuzzTargetInput};

use cedar_lean_ffi::CedarLeanFfi;
use cedar_policy::{Policy, PolicySet, Schema};
use cedar_policy_symcc::{always_allows_asserts, term::Term, CompiledPolicySet};

use log::debug;
use std::{collections::BTreeSet, convert::TryFrom};

// Fuzzing target checking that terms generated by Lean and Rust SymCC implementations are equivalent
fuzz_target!(|input: SinglePolicyFuzzTargetInput| {
    initialize_log();
    let lean_ffi = CedarLeanFfi::new();
    let mut policyset = PolicySet::new();
    let policy: Policy = input.policy.into();
    policyset.add(policy.clone()).unwrap();
    debug!("Schema: {}\n", input.schema.schemafile_string());
    debug!("Policies: {policy}\n");

    if let Ok(schema) = Schema::try_from(input.schema) {
        let lean_schema = lean_ffi.load_lean_schema_object(&schema).unwrap();
        for req_env in schema.request_envs() {
            // The validator DRT property we've been testing is that
            // rust_passes_validation => lean_passes_validation
            // So, we run the Rust validator first and obtain a well-typed
            // policy. This policy should be also well-typed according to Lean.
            if let Ok(compiled_policies) = CompiledPolicySet::compile(&policyset, &req_env, &schema)
            {
                let rust_asserts = always_allows_asserts(&compiled_policies);
                match lean_ffi.asserts_of_check_always_allows(
                    &compiled_policies.policies().clone().try_into().unwrap(),
                    lean_schema.clone(),
                    &req_env,
                ) {
                    Ok(Ok(lean_asserts)) => {
                        let lean_asserts = lean_asserts
                            .into_iter()
                            .map(|t| Term::try_from(t).expect("term conversion should succeed"))
                            .collect::<BTreeSet<_>>();
                        let rust_asserts =
                            BTreeSet::from_iter(rust_asserts.asserts().as_ref().iter().cloned());
                        similar_asserts::assert_eq!(
                            lean_asserts,
                            rust_asserts,
                            "Lean terms: {lean_asserts:?}, Rust terms: {rust_asserts:?}"
                        );
                    }
                    Err(err) => {
                        panic!("Lean errors while Rust does not: {err}")
                    }
                    Ok(Err(err)) => {
                        panic!("Lean errors while Rust does not: {err}")
                    }
                }
            }
        }
    }
});
