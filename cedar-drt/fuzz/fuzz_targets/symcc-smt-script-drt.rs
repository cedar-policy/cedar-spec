/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#![no_main]
use cedar_drt::logger::initialize_log;
use cedar_drt_inner::{fuzz_target, symcc::SinglePolicyFuzzTargetInput};

use cedar_lean_ffi::CedarLeanFfi;
use cedar_policy::{Policy, PolicySet, Schema};
use cedar_policy_symcc::{
    CedarSymCompiler, CompiledPolicySet, WellFormedAsserts, always_allows_asserts,
    solver::WriterSolver,
};

use log::debug;
use std::convert::TryFrom;
use std::sync::LazyLock;

static RUNTIME: LazyLock<tokio::runtime::Runtime> = LazyLock::new(|| {
    tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap()
});

fn smtlib_of_check_asserts(rust_asserts: &WellFormedAsserts<'_>) -> Result<String, String> {
    RUNTIME.block_on(async {
        let mut solver = CedarSymCompiler::new(WriterSolver {
            w: Vec::<u8>::new(),
        })
        .expect("solver construction should succeed");
        match solver.check_sat(rust_asserts).await {
            Ok(_) | Err(cedar_policy_symcc::err::Error::SolverUnknown) => {
                Ok(String::from_utf8(std::mem::take(&mut solver.solver_mut().w)).unwrap())
            }
            Err(e) => Err(e.to_string()),
        }
    })
}

// Fuzzing target checking that Term to SMT-LIB encodings generated by Lean and Rust SymCC implementations are equivalent
// cspell:ignore symcc
fuzz_target!(|input: SinglePolicyFuzzTargetInput| {
    initialize_log();
    let lean_ffi = CedarLeanFfi::new();
    let mut policyset = PolicySet::new();
    let policy: Policy = input.policy.into();
    policyset.add(policy.clone()).unwrap();
    debug!("Schema: {}\n", input.schema.schemafile_string());
    debug!("Policies: {policy}\n");

    if let Ok(schema) = Schema::try_from(input.schema) {
        let lean_schema = lean_ffi.load_lean_schema_object(&schema).unwrap();
        for req_env in schema.request_envs() {
            // We let Rust compile the policies as it's faster than Lean
            if let Ok(cps) = CompiledPolicySet::compile(&policyset, &req_env, &schema) {
                let rust_asserts = always_allows_asserts(&cps);
                let lean_asserts: Vec<_> = rust_asserts
                    .asserts()
                    .iter()
                    .map(|assert| assert.clone().into())
                    .collect();
                debug!("Lean asserts: {lean_asserts:#?}");
                match (
                    smtlib_of_check_asserts(&rust_asserts),
                    lean_ffi.smtlib_of_check_asserts(&lean_asserts, lean_schema.clone(), &req_env),
                ) {
                    (Ok(rust_smtlib), Ok(lean_smtlib)) => {
                        similar_asserts::assert_eq!(
                            rust_smtlib,
                            lean_smtlib,
                            "Rust:\n{rust_smtlib}\nLean:\n{lean_smtlib}"
                        );
                    }
                    (Ok(_), Err(e)) => {
                        panic!("Lean encoding should succeed: {e}");
                    }
                    (Err(e), Ok(_)) => {
                        panic!("Rust encoding should succeed: {e}");
                    }
                    (Err(_), Err(_)) => {}
                }
            }
        }
    }
});
