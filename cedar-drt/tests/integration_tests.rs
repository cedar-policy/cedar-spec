/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! Integration test that runs the handwritten test cases from
//! `cedar-integration-tests` on the definitional implementation.

#![cfg(feature = "integration-testing")]

use cedar_testing::cedar_test_impl::{time_function, CedarTestImplementation};
use cedar_testing::integration_testing::{
    perform_integration_test_from_json_custom, resolve_integration_test_path,
};

use cedar_drt::*;
use std::path::{Path, PathBuf};
use std::time::Duration;
use walkdir::WalkDir;

use cedar_testing::integration_testing::*;
use prost::Message;
use statrs::statistics::{Data, Distribution};

/// Path of the folder containing the (handwritten) integration tests
fn integration_test_folder() -> &'static Path {
    Path::new("tests")
}

/// Path of the folder containing the autogenerated corpus tests
fn corpus_test_folder() -> &'static Path {
    Path::new("corpus-tests")
}

/// Pull out the relevant tests in `integration_test_folder()`
pub fn get_integration_tests() -> impl Iterator<Item = PathBuf> {
    let tests_folder = resolve_integration_test_path(integration_test_folder());
    // find all `*.json` files in the integration tests folder
    WalkDir::new(&tests_folder)
        .into_iter()
        .map(|e| e.expect("failed to access file in tests").into_path())
        // ignore non-JSON files (and directories, which don't have an extension)
        .filter(|p| {
            p.extension()
                .map(|ext| ext.eq_ignore_ascii_case("json"))
                .unwrap_or(false)
        })
}

/// Pull out the relevant tests in `corpus_test_folder()`
pub fn get_corpus_tests() -> impl Iterator<Item = PathBuf> {
    let tests_folder = resolve_integration_test_path(corpus_test_folder());
    WalkDir::new(&tests_folder)
        .into_iter()
        .map(|e| {
            e.expect("failed to access file in corpus_tests. Maybe you haven't unpacked `corpus-tests.tar.gz`")
                .into_path()
        })
        .filter(|p| {
            let filename = p
                .file_name()
                .expect("didn't expect subdirectories in corpus-tests")
                .to_str()
                .expect("expected filenames to be valid UTF-8");
            filename.ends_with(".json") && !filename.ends_with(".entities.json")
        })
}

fn run_tests(custom_impl: &impl CedarTestImplementation, tests: impl Iterator<Item = PathBuf>) {
    for test_json in tests {
        perform_integration_test_from_json_custom(&test_json, custom_impl);
    }
}

fn run_integration_tests(custom_impl: &impl CedarTestImplementation) {
    run_tests(custom_impl, get_integration_tests());
}

fn run_corpus_tests(custom_impl: &impl CedarTestImplementation) {
    run_tests(custom_impl, get_corpus_tests());
}

#[test]
fn integration_tests_on_def_impl() {
    let lean_def_impl = LeanDefinitionalEngine::new();
    run_integration_tests(&lean_def_impl);
    run_corpus_tests(&lean_def_impl);
}

#[test]
fn protobuf_roundtrip() {
    let tests = get_corpus_tests();
    let mut proto_serialize_durs: Vec<f64> = vec![];
    let mut proto_serialize_sizes: Vec<f64> = vec![];
    let mut proto_deserialize_durs: Vec<f64> = vec![];

    for test in tests {
        // Load test from JSON file
        let jsonfile = resolve_integration_test_path(test);
        let test_name: String = jsonfile.display().to_string();
        let jsonstr = std::fs::read_to_string(jsonfile.as_path())
            .unwrap_or_else(|e| panic!("error reading from file {test_name}: {e}"));
        let test: JsonTest = serde_json::from_str(&jsonstr)
            .unwrap_or_else(|e| panic!("error parsing {test_name}: {e}"));
        let policies = parse_policies_from_test(&test);
        let schema = parse_schema_from_test(&test);
        let entities = parse_entities_from_test(&test, &schema);
        let requests: Vec<ast::Request> = test
            .requests
            .into_iter()
            .map(|json_request| parse_request_from_test(&json_request, &schema, &test_name))
            .collect();

        for request in requests {
            // Construct Message
            let request_msg = AuthorizationRequest {
                request: &request,
                policies: &policies,
                entities: &entities,
            };

            // Perform a roundtrip serialize/de-serialize from protobuf and AST
            let request_msg_proto = proto::AuthorizationRequest::from(&request_msg);
            let request_msg_rt = OwnedAuthorizationRequest::from(request_msg_proto);

            // Checking request equality (ignores loc field)
            assert_eq!(
                request_msg.request.principal().uid(),
                request_msg_rt.request.principal().uid()
            );
            assert_eq!(
                request_msg.request.action().uid(),
                request_msg_rt.request.action().uid()
            );
            assert_eq!(
                request_msg.request.resource().uid(),
                request_msg_rt.request.resource().uid()
            );
            assert_eq!(
                request_msg.request.context(),
                request_msg_rt.request.context()
            );

            // Checking policy set equality
            assert_eq!(request_msg.policies, &request_msg_rt.policies);

            // Checking entities equality
            assert_eq!(request_msg.entities, &request_msg_rt.entities);

            // Time protobuf serialization from AST -> bytes
            let (request_msg_proto, proto_serialize_dur): (Vec<u8>, Duration) =
                time_function(|| proto::AuthorizationRequest::from(&request_msg).encode_to_vec());

            // Time protobuf deserialization from bytes -> AST
            let (_request_msg_rt, proto_deserialize_dur) = time_function(|| {
                OwnedAuthorizationRequest::from(
                    proto::AuthorizationRequest::decode(&request_msg_proto[..])
                        .expect("Failed to deserialize AuthorizationRequest proto"),
                )
            });

            // Log protobuf timings and size of byte representation
            proto_serialize_durs.push(proto_serialize_dur.as_micros() as f64);
            proto_serialize_sizes.push(
                (std::mem::size_of::<Vec<u8>>()
                    + request_msg_proto.capacity() * std::mem::size_of::<u8>())
                    as f64,
            );
            proto_deserialize_durs.push(proto_deserialize_dur.as_micros() as f64);
        }
    }

    // Print summary statistics

    let total_tests = proto_serialize_durs.len();
    println!("Total Number of tests: {total_tests}\n");

    let d_proto_serialize_dur = Data::new(proto_serialize_durs);
    let mean_proto_serialize_dur = d_proto_serialize_dur.mean().unwrap();
    let std_proto_serialize_dur = d_proto_serialize_dur.std_dev().unwrap();
    println!("Protobuf Mean Serialization Time {mean_proto_serialize_dur} micros");
    println!("Protobuf Std Serialization Time {std_proto_serialize_dur} micros\n");

    let d_proto_serialize_sizes = Data::new(proto_serialize_sizes);
    let mean_proto_serialize_size = d_proto_serialize_sizes.mean().unwrap();
    let std_proto_serialize_size = d_proto_serialize_sizes.std_dev().unwrap();
    println!("Protobuf Mean Serialization Size {mean_proto_serialize_size} bytes");
    println!("Protobuf Std Serialization Size {std_proto_serialize_size} bytes\n");

    let d_proto_deserialize_durs = Data::new(proto_deserialize_durs);
    let mean_proto_deserialize_dur = d_proto_deserialize_durs.mean().unwrap();
    let std_proto_deserialize_dur = d_proto_deserialize_durs.std_dev().unwrap();
    println!("Protobuf Mean Deserialization Time {mean_proto_deserialize_dur} micros");
    println!("Protobuf Std Deserialization Time {std_proto_deserialize_dur} micros\n");
}
