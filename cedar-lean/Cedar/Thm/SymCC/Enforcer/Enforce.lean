/-
 Copyright Cedar Contributors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-/

import Cedar.SymCC.Enforcer
import Cedar.Thm.SymCC.Enforcer.Acyclicity
import Cedar.Thm.SymCC.Enforcer.Asserts
import Cedar.Thm.SymCC.Enforcer.Extractor
import Cedar.Thm.SymCC.Enforcer.Footprint
import Cedar.Thm.SymCC.Enforcer.Compile
import Cedar.Thm.SymCC.Enforcer.Transitivity
import Cedar.Thm.SymCC.Compiler

/-!
This file proves key auxiliary lemmas for the strong well-formedness assumptions
generated by the `enforce` function in `Cedar/SymCC/Enforcer.lean`.
--/

namespace Cedar.Thm

open Data Spec SymCC Factory

private def acyclic (ft : Set Term) (εs : SymEntities) : List Term :=
  ft.elts.map (acyclicity · εs)

private def transitive (ft : Set Term) (εs : SymEntities) : List Term :=
  ft.elts.mapUnion (λ t => ft.elts.map (transitivity t · εs))

private theorem enforce_def {xs : List Expr} {εnv : SymEnv} :
  enforce xs εnv =
  Set.make (acyclic (footprints xs εnv) εnv.entities ∪
            transitive (footprints xs εnv) εnv.entities)
:= by
  simp only [enforce, acyclic, transitive]

private theorem swf_implies_acyclic {xs : List Expr} {env : Env} {εnv : SymEnv} {I : Interpretation} {t : Term}
  (heq : env ∼ SymEnv.interpret I εnv)
  (hI : I.WellFormed εnv.entities)
  (hsε : εnv.StronglyWellFormedForAll xs)
  (hse : env.StronglyWellFormedForAll xs)
  (hin : t ∈ acyclic (footprints xs εnv) εnv.entities) :
  Term.interpret I t = Term.prim (TermPrim.bool true)
:= by
  simp only [acyclic, List.mem_map] at hin
  replace ⟨tₑ, hin, ha⟩ := hin
  subst ha
  simp only [Set.in_list_iff_in_set, mem_footprints_iff] at hin
  replace ⟨xᵢ, hinₓ, hin⟩ := hin
  replace hsε := swf_εnv_all_implies_swf_all hsε xᵢ hinₓ
  replace hse := swf_env_all_implies_swf_all hse xᵢ hinₓ
  have ⟨_, hty⟩ := mem_footprint_option_entity hin
  replace ⟨xₑ, hsεₑ, hseₑ, hok⟩ := mem_footprint_compile_exists_swf hsε hse hin
  exact swf_implies_interpret_acyclicity heq hI (swf_εnv_for_implies_wf_for hsεₑ) hseₑ hok hty

private theorem swf_implies_transitive {xs : List Expr} {env : Env} {εnv : SymEnv} {I : Interpretation} {t : Term}
  (heq : env ∼ SymEnv.interpret I εnv)
  (hI : I.WellFormed εnv.entities)
  (hsε : εnv.StronglyWellFormedForAll xs)
  (hse : env.StronglyWellFormedForAll xs)
  (hin : t ∈ transitive (footprints xs εnv) εnv.entities) :
  Term.interpret I t = Term.prim (TermPrim.bool true)
:= by
  simp only [transitive, List.mem_mapUnion_iff_mem_exists] at hin
  replace ⟨t₁, hin₁, hin⟩ := hin
  simp only [List.mem_map] at hin
  replace ⟨t₂, hin₂, hin⟩ := hin
  subst hin
  simp only [Set.in_list_iff_in_set, mem_footprints_iff] at hin₁ hin₂
  replace ⟨x₁, hinx₁, hin₁⟩ := hin₁
  replace ⟨x₂, hinx₂, hin₂⟩ := hin₂
  have hsε₁ := swf_εnv_all_implies_swf_all hsε x₁ hinx₁
  have hse₁ := swf_env_all_implies_swf_all hse x₁ hinx₁
  have hsε₂ := swf_εnv_all_implies_swf_all hsε x₂ hinx₂
  have hse₂ := swf_env_all_implies_swf_all hse x₂ hinx₂
  have ⟨_, hty₁⟩ := mem_footprint_option_entity hin₁
  have ⟨_, hty₂⟩ := mem_footprint_option_entity hin₂
  replace ⟨x₁, hsε₁, hse₁, hok₁⟩ := mem_footprint_compile_exists_swf hsε₁ hse₁ hin₁
  replace ⟨x₂, hsε₂, hse₂, hok₂⟩ := mem_footprint_compile_exists_swf hsε₂ hse₂ hin₂
  exact swf_implies_interpret_transitivity heq hI
    (swf_εnv_for_implies_wf_for hsε₁) (swf_εnv_for_implies_wf_for hsε₂)
    hse₁ hse₂ hok₁ hok₂ hty₁ hty₂

theorem enforce_satisfiedBy_swf {xs : List Expr} {env : Env} {εnv : SymEnv} {I : Interpretation} {assumes : Asserts} :
  env ∼ εnv.interpret I →
  I.WellFormed εnv.entities →
  εnv.StronglyWellFormedForAll xs →
  env.StronglyWellFormedForAll xs →
  enforce xs εnv = Set.mk assumes →
  assumes.satisfiedBy I
:= by
  intro heq hI hsε hse ha
  rw [asserts_satisfiedBy_true]
  intro t hin
  rw [enforce_def] at ha
  rw [Set.in_list_iff_in_mk, ← ha, ← Set.make_mem, List.mem_union_iff] at hin
  rcases hin with hin | hin
  · exact swf_implies_acyclic heq hI hsε hse hin
  · exact swf_implies_transitive heq hI hsε hse hin

private theorem εnv_interpret_find?_ancestor {εnv : SymEnv} {I : Interpretation} {δ : SymEntityData} {ancUF : UnaryFunction} {ety₁ ety₂ : EntityType}
  (hδ : (εnv.interpret I).entities.find? ety₁ = some δ)
  (hf : δ.ancestors.find? ety₂ = some ancUF) :
  ∃ δ' ancUF',
    εnv.entities.find? ety₁ = some δ' ∧
    δ'.interpret I = δ ∧
    δ'.ancestors.find? ety₂ = some ancUF' ∧
    ancUF'.interpret I = ancUF
:= by
  simp only [SymEnv.interpret, SymEntities.interpret, ← Map.find?_mapOnValues, Option.map_eq_some'] at hδ
  replace ⟨_, hδ⟩ := hδ
  simp only [hδ, Option.some.injEq, exists_and_left, exists_eq_left', true_and]
  simp only [← hδ.right, SymEntityData.interpret, ← Map.find?_mapOnValues, Option.map_eq_some'] at hf
  replace ⟨_, hf⟩ := hf
  simp only [hf, Option.some.injEq, exists_eq_left']

private theorem mem_terms_mem_entityUIDs {uid : EntityUID} {ts : Set Term} :
  Term.entity uid ∈ ts →
  uid ∈ (Term.set ts (.entity uid.ty)).entityUIDs
:= by
  intro hin
  unfold Term.entityUIDs
  simp only [List.attach_def, List.mapUnion_pmap_subtype, Set.mem_mapUnion_iff_mem_exists]
  exists Term.entity uid
  simp only [Set.in_list_iff_in_set, hin, Term.entityUIDs, TermPrim.entityUIDs,
    Set.mem_singleton_iff_eq, and_self]

private theorem mem_entityUIDs_mem_terms {uid : EntityUID} {ts : Set Term} {ety : EntityType} {εs : SymEntities} :
  (Term.set ts (.entity ety)).WellFormedLiteral εs →
  uid ∈ (Term.set ts (.entity ety)).entityUIDs →
  Term.entity uid ∈ ts
:= by
  intro ⟨hwf, hlit⟩ hin
  unfold Term.entityUIDs at hin
  simp only [List.attach_def, List.mapUnion_pmap_subtype, Set.mem_mapUnion_iff_mem_exists] at hin
  replace ⟨t, hinₜ, hin⟩ := hin
  have hwt := wf_term_set_implies_wf_elt hwf hinₜ
  have hty := wf_term_set_implies_typeOf_elt hwf hinₜ
  have hlt := lit_term_set_implies_lit_elt hlit hinₜ
  have ⟨_, heq, _⟩ := wfl_of_type_entity_is_entity (And.intro hwt hlt) hty
  subst heq
  simp only [Term.entityUIDs, TermPrim.entityUIDs, Set.mem_singleton_iff_eq] at hin
  subst hin
  simp only [← Set.in_list_iff_in_set, hinₜ]

private theorem same_env_implies_find? {uid₁ uid₂ : EntityUID} {d₁ : EntityData} {env : Env} {εnv : SymEnv} {I : Interpretation}
  (heq : env ∼ εnv.interpret I)
  (hd₁ : env.entities.find? uid₁ = some d₁)
  (hin : uid₂ ∈ d₁.ancestors) :
  ∃ δ f ts,
    Map.find? εnv.entities uid₁.ty = some δ ∧
    δ.ancestors.find? uid₂.ty = some f ∧
    app (f.interpret I) (Term.prim (TermPrim.entity uid₁)) = Term.set ts (TermType.entity uid₂.ty) ∧
    Term.entity uid₂ ∈ ts
:= by
  replace ⟨δ, hδ, heq⟩ := heq.right uid₁ d₁ hd₁
  replace ⟨f, hf, ts, heq, hinᵤ⟩ := heq.right.left uid₂ hin
  replace ⟨δ, f, hδ, heqδ, hf, heqf⟩ := εnv_interpret_find?_ancestor hδ hf
  subst heqδ heqf
  exists δ, f, ts


local macro "simp_not_mem_footprint" hwε:ident hI:ident hδ:ident hf:ident happ:ident hin:ident hft:ident : tactic => do
 `(tactic| (
    rw [Bool.eq_false_iff, ne_eq, Set.contains_prop_bool_equiv] at $hft:ident
    simp only [not_mem_footprintUIDs_implies_empty_ancs $hwε $hI $hδ $hf $hft, Term.set.injEq, and_true] at $happ:ident
    subst $happ
    simp only [Set.empty_no_elts] at $hin:ident))

private theorem acyclic_implies_Acyclic {xs : List Expr} {env : Env} {εnv : SymEnv} {I : Interpretation}
  (hsε : εnv.StronglyWellFormedForAll xs)
  (hI  : I.WellFormed εnv.entities)
  (heq : env ∼ εnv.interpret (Interpretation.repair xs εnv I))
  (hok : ∀ t ∈ acyclic (footprints xs εnv) εnv.entities, Term.interpret I t = true) :
  env.entities.Acyclic
:= by
  intro uid d hd
  by_contra hin
  simp only [acyclic, Set.in_list_iff_in_set, List.mem_map, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂] at hok
  have ⟨δ, f, ts, hδ, hf, heq, hinᵤ⟩ := same_env_implies_find? heq hd hin
  cases f
  case uuf f =>
    have hwε := swf_εnv_implies_wf hsε.left
    cases hft : (Interpretation.repair.footprintUIDs xs εnv I).contains uid
    case false =>
      simp_not_mem_footprint hwε hI hδ hf heq hinᵤ hft
    case true =>
      rw [Set.contains_prop_bool_equiv] at hft
      have ⟨t, hinₜ, ht⟩ := mem_footprintUIDs_mem_footprints hwε hsε.right hI hft
      specialize hok t hinₜ
      simp only [mem_footprintUIDs_implies_eq_ancs hwε hI hδ hf hft] at heq
      have hwt := mem_footprints_wf hwε hsε.right hinₜ
      have _ := interpret_acyclicity_implies_acyclic hwε hI hwt hδ hf ht heq hok
      contradiction
  case udf f =>
    simp only [UnaryFunction.interpret] at heq
    replace hsε := hsε.left.right.right.left uid δ f hδ hf
    simp only [heq] at hsε
    replace hinₜ := mem_terms_mem_entityUIDs hinᵤ
    contradiction

private theorem wf_δ_implies_wf_app_udf_ancs {uid : EntityUID} {δ : SymEntityData} {εs : SymEntities} {ancTy : EntityType} {ancUF : UDF} :
  δ.WellFormed εs uid.ty →
  δ.ancestors.find? ancTy = some (.udf ancUF) →
  (app (.udf ancUF) (Term.entity uid)).WellFormedLiteral εs ∧
  (app (.udf ancUF) (Term.entity uid)).typeOf = .set (.entity ancTy)
:= by
  intro hwδ hf
  have ⟨hwf, _, htyₒ⟩ := hwδ.right.right.right.left ancTy (.udf ancUF) hf
  simp only [app, term_prim_is_lit, ↓reduceIte]
  simp only [UnaryFunction.outType] at htyₒ
  simp only [UnaryFunction.WellFormed, UDF.WellFormed, htyₒ] at hwf
  split
  · rename_i tₒ hf
    replace hwf := hwf.right.right.right (Term.entity uid) tₒ (Map.find?_mem_toList hf)
    simp only [hwf, and_self]
  · simp only [hwf, and_self]

private theorem wfl_entities_implies_mem_entityUIDs_type {uid : EntityUID} {t : Term} {ety : EntityType} {εs : SymEntities} :
  t.WellFormedLiteral εs →
  t.typeOf = .set (.entity ety) →
  uid ∈ t.entityUIDs →
  uid.ty = ety
:= by
  intro hwl hty hin
  have ⟨ts, heq⟩ := wfl_of_type_set_is_set hwl hty
  subst heq
  replace hin := mem_entityUIDs_mem_terms hwl hin
  replace hin := wf_term_set_implies_typeOf_elt hwl.left hin
  simp only [typeOf_term_prim_entity, TermType.prim.injEq, TermPrimType.entity.injEq] at hin
  exact hin

private theorem partitioned_implies_ancestors_isUDF_eq {ety₁ ety₂ ety₃ : EntityType} {δ₁ δ₂ : SymEntityData} {f₁₂ f₂₃ : UnaryFunction} {εs : SymEntities}
  (hsε : εs.Partitioned)
  (hδ₁ : Map.find? εs ety₁ = some δ₁)
  (hf₁ : δ₁.ancestors.find? ety₂ = some f₁₂)
  (hδ₂ : Map.find? εs ety₂ = some δ₂)
  (hf₂ : δ₂.ancestors.find? ety₃ = f₂₃) :
  f₁₂.isUDF = f₂₃.isUDF
:= by
  have ⟨hpd₁, hpd₂⟩ := hsε
  specialize hpd₂ ety₁ δ₁ f₁₂ ety₂ δ₂ hδ₁ hδ₂ hf₁
  have henum₁ := hpd₁ ety₁ δ₁ hδ₁
  have henum₂ := hpd₁ ety₂ δ₂ hδ₂
  simp only [SymEntityData.PartitionedAncestors, hpd₂] at henum₁ henum₂
  cases h : δ₂.isEnum <;>
  simp only [h, Bool.false_eq_true, ↓reduceIte] at henum₁ henum₂ <;>
  specialize henum₁ ety₂ f₁₂ hf₁ <;>
  specialize henum₂ ety₃ f₂₃ hf₂
  · simp only [UnaryFunction.isUUF, UnaryFunction.isUDF] at *
    cases f₁₂ <;> cases f₂₃ <;>
    simp only [Bool.false_eq_true] at *
  · simp only [henum₁, henum₂]

private theorem partitioned_uuf_implies_isUUF {ety pty₁ pty₂ : EntityType} {δ : SymEntityData} {f₁ : UUF} {f₂ : UnaryFunction} {εs : SymEntities}
  (hsε : εs.Partitioned)
  (hδ  : Map.find? εs ety = some δ)
  (hf₁ : δ.ancestors.find? pty₁ = some (.uuf f₁))
  (hf₂ : δ.ancestors.find? pty₂ = some f₂) :
  f₂.isUUF
:= by
  replace hsε := hsε.left ety δ hδ
  simp only [SymEntityData.PartitionedAncestors] at hsε
  split at hsε
  · specialize hsε pty₁ (.uuf f₁) hf₁
    simp only [UnaryFunction.isUDF, Bool.false_eq_true] at hsε
  · exact hsε pty₂ f₂ hf₂

private theorem same_envs_implies_exists_ancestors_of_type
  {uid₁ : EntityUID} {ety₂ : EntityType} {d₁ : EntityData} {δ₁ : SymEntityData}
  {f₁₂ : UnaryFunction} {env : Env} {εnv : SymEnv} {I : Interpretation}
  (heq  : env ∼ εnv.interpret I)
  (hd₁  : Map.find? env.entities uid₁ = some d₁)
  (hδ₁  : Map.find? εnv.entities uid₁.ty = some δ₁)
  (hf₁  : δ₁.ancestors.find? ety₂ = some f₁₂) :
  ∃ ts₂ : Set Term,
    app (f₁₂.interpret I) (.entity uid₁) = .set ts₂ (.entity ety₂) ∧
    ∀ (t : Term), t ∈ ts₂ → ∃ anc, t = .entity anc ∧ anc ∈ d₁.ancestors
:= by
  replace ⟨δ₁', hδ₁', heq⟩ := heq.right uid₁ d₁ hd₁
  simp only [SymEnv.interpret, interpret_entities_find?_some hδ₁, Option.some.injEq] at hδ₁'
  subst hδ₁'
  replace heq := heq.right.right.left ety₂ (f₁₂.interpret I)
  simp only [SymEntityData.interpret, ← Map.find?_mapOnValues, Option.map_eq_some', forall_exists_index, and_imp] at heq
  replace ⟨ts₂, heq, hts₂⟩ := heq f₁₂ hf₁ rfl
  exists ts₂

private theorem transitive_implies_Transitive_uuf_uuf
  {uid₁ uid₂ uid₃ : EntityUID} {d₁ : EntityData}
  {δ₁ δ₂ : SymEntityData} {f₁₂ f₂₃ : UUF} {ts₁₂ ts₂₃ : Set Term}
  {xs : List Expr} {env : Env} {εnv : SymEnv} {I : Interpretation}
  (hsε : εnv.StronglyWellFormedForAll xs)
  (hI  : I.WellFormed εnv.entities)
  (heq : env ∼ εnv.interpret (I.repair xs εnv))
  (hok : ∀ t ∈ transitive (footprints xs εnv) εnv.entities, t.interpret I = true)
  (hd₁ : Map.find? env.entities uid₁ = some d₁)
  (hδ₁ : Map.find? εnv.entities uid₁.ty = some δ₁)
  (hf₁ : δ₁.ancestors.find? uid₂.ty = some (.uuf f₁₂))
  (heq₁ : app ((UnaryFunction.uuf f₁₂).interpret (I.repair xs εnv)) (.entity uid₁) = .set ts₁₂ (.entity uid₂.ty))
  (hu₂₁ : Term.entity uid₂ ∈ ts₁₂)
  (hδ₂ : Map.find? εnv.entities uid₂.ty = some δ₂)
  (hf₂ : δ₂.ancestors.find? uid₃.ty = some (.uuf f₂₃))
  (heq₂ : app ((UnaryFunction.uuf f₂₃).interpret (I.repair xs εnv)) (.entity uid₂) = .set ts₂₃ (.entity uid₃.ty))
  (hu₃₂ : Term.entity uid₃ ∈ ts₂₃) :
  uid₃ ∈ d₁.ancestors
:= by
  have hwε := swf_εnv_implies_wf hsε.left
  cases hft₁ : (Interpretation.repair.footprintUIDs xs εnv I).contains uid₁ <;>
  cases hft₂ : (Interpretation.repair.footprintUIDs xs εnv I).contains uid₂
  case false.false | false.true =>
    simp_not_mem_footprint hwε hI hδ₁ hf₁ heq₁ hu₂₁ hft₁
  case true.false =>
    simp_not_mem_footprint hwε hI hδ₂ hf₂ heq₂ hu₃₂ hft₂
  case true.true =>
    rw [Set.contains_prop_bool_equiv] at hft₁ hft₂
    have ⟨t₁, hin₁, ht₁⟩ := mem_footprintUIDs_mem_footprints hwε hsε.right hI hft₁
    have ⟨t₂, hin₂, ht₂⟩ := mem_footprintUIDs_mem_footprints hwε hsε.right hI hft₂
    specialize hok (transitivity t₁ t₂ εnv.entities)
    simp only [transitive, List.mem_mapUnion_iff_mem_exists, List.mem_map, forall_exists_index, and_imp] at hok
    specialize hok t₁ hin₁ t₂ hin₂ rfl
    simp only [mem_footprintUIDs_implies_eq_ancs hwε hI hδ₁ hf₁ hft₁] at heq₁
    simp only [mem_footprintUIDs_implies_eq_ancs hwε hI hδ₂ hf₂ hft₂] at heq₂
    have hwt₁ := mem_footprints_wf hwε hsε.right hin₁
    have hwt₂ := mem_footprints_wf hwε hsε.right hin₂
    have ⟨f₁₃, ts₁₃, hf₃, heq₃, hu₃₁⟩ := interpret_transitivity_implies_transitive
      hwε hI hwt₁ hwt₂ ht₁ ht₂ hδ₁ hf₁ heq₁ hu₂₁
      hδ₂ hf₂ heq₂ hu₃₂ hok
    have huuf := partitioned_uuf_implies_isUUF hsε.left.right.right.right.right hδ₁ hf₁ hf₃
    simp only [UnaryFunction.isUUF] at huuf
    split at huuf <;> simp only [Bool.false_eq_true] at huuf
    rename_i f₁₃
    replace ⟨ts₃, heq, hts₃⟩ := same_envs_implies_exists_ancestors_of_type heq hd₁ hδ₁ hf₃
    simp only [← mem_footprintUIDs_implies_eq_ancs hwε hI hδ₁ hf₃ hft₁] at heq₃
    simp only [heq, Term.set.injEq, and_true] at heq₃
    subst heq₃
    specialize hts₃ (Term.entity uid₃) hu₃₁
    simp only [Term.prim.injEq, TermPrim.entity.injEq, exists_eq_left'] at hts₃
    exact hts₃

private theorem transitive_implies_Transitive_udf_udf
  {uid₁ uid₂ uid₃ : EntityUID} {d₁ : EntityData}
  {δ₁ δ₂ : SymEntityData} {f₁₂ f₂₃ : UDF} {ts₁₂ ts₂₃ : Set Term}
  {env : Env} {εnv : SymEnv} {I : Interpretation}
  (hsε : εnv.StronglyWellFormed)
  (heq : env ∼ εnv.interpret I)
  (hd₁ : Map.find? env.entities uid₁ = some d₁)
  (hδ₁ : Map.find? εnv.entities uid₁.ty = some δ₁)
  (hf₁ : δ₁.ancestors.find? uid₂.ty = some (UnaryFunction.udf f₁₂))
  (heq₁ : app (UnaryFunction.udf f₁₂) (Term.prim (TermPrim.entity uid₁)) = Term.set ts₁₂ (TermType.entity uid₂.ty))
  (hu₂₁ : Term.entity uid₂ ∈ ts₁₂)
  (hδ₂ : Map.find? εnv.entities uid₂.ty = some δ₂)
  (hf₂ : δ₂.ancestors.find? uid₃.ty = some (UnaryFunction.udf f₂₃))
  (heq₂ : app (UnaryFunction.udf f₂₃) (Term.prim (TermPrim.entity uid₂)) = Term.set ts₂₃ (TermType.entity uid₃.ty))
  (hu₃₂ : Term.entity uid₃ ∈ ts₂₃) :
  uid₃ ∈ d₁.ancestors
:= by
  have htr := hsε.right.right.right.left uid₁ δ₁ uid₂ δ₂ hδ₁ hδ₂
  simp only [SymEntityData.knownAncestors, Set.mem_mapUnion_iff_mem_exists, forall_exists_index, and_imp] at htr
  specialize htr (uid₂.ty, .udf f₁₂) (Map.find?_mem_toList hf₁)
  simp only [SymEntityData.knownAncestors.ancs, heq₁, mem_terms_mem_entityUIDs hu₂₁, Set.subset_def, true_implies] at htr
  specialize htr uid₃
  simp only [Set.mem_mapUnion_iff_mem_exists, forall_exists_index, and_imp] at htr
  specialize htr (uid₃.ty, .udf f₂₃) (Map.find?_mem_toList hf₂)
  simp only [SymEntityData.knownAncestors.ancs, heq₂, mem_terms_mem_entityUIDs hu₃₂, true_implies] at htr
  replace ⟨(ety₃, f₁₃), hin₁₃, htr⟩ := htr
  split at htr <;> try simp only [Set.empty_no_elts] at htr
  rename_i f₁₃ heq₃
  simp only [Prod.mk.injEq] at heq₃
  replace ⟨heq₃, heq₃'⟩ := heq₃
  subst heq₃ heq₃'
  replace hin₁₃ := Map.mem_toList_find? ((hsε.right.left.right uid₁.ty δ₁ hδ₁).right.right.right.right.left) hin₁₃
  have ⟨hwl, hty⟩ := wf_δ_implies_wf_app_udf_ancs (hsε.right.left.right uid₁.ty δ₁ hδ₁) hin₁₃
  have hty₃ := wfl_entities_implies_mem_entityUIDs_type hwl hty htr
  subst hty₃
  replace ⟨ts₃, heq, hts₃⟩ := same_envs_implies_exists_ancestors_of_type heq hd₁ hδ₁ hin₁₃
  simp only [UnaryFunction.interpret] at heq
  simp only [heq] at hwl htr
  specialize hts₃ (Term.entity uid₃) (mem_entityUIDs_mem_terms hwl htr)
  simp only [Term.prim.injEq, TermPrim.entity.injEq, exists_eq_left'] at hts₃
  exact hts₃

private theorem transitive_implies_Transitive {xs : List Expr} {env : Env} {εnv : SymEnv} {I : Interpretation}
  (hsε : εnv.StronglyWellFormedForAll xs)
  (hI  : I.WellFormed εnv.entities)
  (heq : env ∼ εnv.interpret (I.repair xs εnv))
  (hok : ∀ t ∈ transitive (footprints xs εnv) εnv.entities, t.interpret I = true) :
  env.entities.Transitive
:= by
  intro uid₁ d₁ uid₂ d₂ hd₁ hd₂ hin₂₁
  rw [Set.subset_def]
  intro uid₃ hin₃₂
  have ⟨δ₁, f₁₂, ts₁₂, hδ₁, hf₁, heq₁, hu₂₁⟩ := same_env_implies_find? heq hd₁ hin₂₁
  have ⟨δ₂, f₂₃, ts₂₃, hδ₂, hf₂, heq₂, hu₃₂⟩ := same_env_implies_find? heq hd₂ hin₃₂
  cases f₁₂ <;> cases f₂₃ <;> rename_i f₁₂ f₂₃
  case uuf.uuf =>
    exact transitive_implies_Transitive_uuf_uuf hsε hI heq hok hd₁ hδ₁ hf₁ heq₁ hu₂₁ hδ₂ hf₂ heq₂ hu₃₂
  case uuf.udf | udf.uuf =>
    have hudf := partitioned_implies_ancestors_isUDF_eq hsε.left.right.right.right.right hδ₁ hf₁ hδ₂ hf₂
    simp only [UnaryFunction.isUDF, Bool.false_eq_true, reduceCtorEq] at hudf
  case udf.udf =>
    simp only [UnaryFunction.interpret] at heq₁ heq₂
    exact transitive_implies_Transitive_udf_udf hsε.left heq hd₁ hδ₁ hf₁ heq₁ hu₂₁ hδ₂ hf₂ heq₂ hu₃₂

private theorem enforce_satisfiedBy_implies_acyclic_and_transitive {xs : List Expr} {εnv : SymEnv} {I : Interpretation} {assumes : Asserts}
  (hok : enforce xs εnv = Set.mk assumes)
  (hsat : Asserts.satisfiedBy I assumes) :
  (∀ t ∈ acyclic (footprints xs εnv) εnv.entities, t.interpret I = true) ∧
  (∀ t ∈ transitive (footprints xs εnv) εnv.entities, t.interpret I = true)
:= by
  rw [enforce_def] at hok
  rw [asserts_satisfiedBy_true] at hsat
  constructor
  all_goals {
    intro t hin
    specialize hsat t
    rw [Set.in_list_iff_in_mk, ← hok, ← Set.make_mem, List.mem_union_iff] at hsat
    simp only [hin, true_or, or_true, true_implies] at hsat
    exact hsat
  }

theorem enforce_satisfiedBy_implies_swf_extract? {xs : List Expr} {εnv : SymEnv} {I : Interpretation} {assumes : Asserts} :
  εnv.StronglyWellFormedForAll xs →
  I.WellFormed εnv.entities →
  enforce xs εnv = Set.mk assumes →
  assumes.satisfiedBy I →
  ∃ (I' : Interpretation) (env : Env),
    env = εnv.extract? xs I ∧
    I'.WellFormed εnv.entities ∧
    env ∼ εnv.interpret I' ∧
    env.StronglyWellFormedForAll xs ∧
    ∀ x t, x ∈ xs → compile x εnv = .ok t → t.interpret I = t.interpret I'
:= by
  intro hsε hI hok hsat
  have hwε := swf_εnv_implies_wf hsε.left
  have hI' := repair_wf hwε hsε.right hI
  have ⟨env', hcex, heq, hwe, hvr⟩ := extract?_env_wf_same hwε hsε.right hI
  exists I.repair xs εnv, env'
  simp only [hcex, hI', heq, true_and]
  constructor
  · constructor
    · simp only [Env.StronglyWellFormed, hwe.left, Entities.StronglyWellFormed,
        hwe.right, Entities.Hierarchical, true_and]
      replace hok := enforce_satisfiedBy_implies_acyclic_and_transitive hok hsat
      constructor
      · exact acyclic_implies_Acyclic hsε hI heq hok.left
      · exact transitive_implies_Transitive hsε hI heq hok.right
    · exact hvr
  · intro x t hx hok
    exact compile_interpret_on_footprint (swf_εnv_all_implies_wf_all hsε x hx)
      hI hI' (εnv_same_on_footprints hsε hI) (footprint_subset_footprints hx) hok

theorem enforce_satisfiedBy_implies_swf {xs : List Expr} {εnv : SymEnv} {I : Interpretation} {assumes : Asserts} :
  εnv.StronglyWellFormedForAll xs →
  I.WellFormed εnv.entities →
  enforce xs εnv = Set.mk assumes →
  assumes.satisfiedBy I →
  ∃ (I' : Interpretation) (env : Env),
    I'.WellFormed εnv.entities ∧
    env ∼ εnv.interpret I' ∧
    env.StronglyWellFormedForAll xs ∧
    ∀ x t, x ∈ xs → compile x εnv = .ok t → t.interpret I = t.interpret I'
:= by
  intro hsε hI hok hsat
  have ⟨I', env, _, _, _⟩ := enforce_satisfiedBy_implies_swf_extract? hsε hI hok hsat
  exists I', env

end Cedar.Thm
