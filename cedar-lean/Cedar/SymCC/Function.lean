/-
 Copyright Cedar Contributors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-/

import Cedar.Spec
import Cedar.SymCC.Term

/-!
This file defines an ADT that represents unary functions over terms. These
functions can be uninterpreted symbols or interpretations of these symbols that
are generated by an SMT solver. We assume that SMT function interpretations take
a fixed format---effectively, a lookup table with a fixed number of entries,
along with a default value that is returned for all elements of the domain that
are not found in the table. The SMT solver represents these tables as nested
`ite` expressions, where each condition checks if the input is equal to a value
in the domain, and if so returns the corresponding output. Our target SMT solver
(CVC5) always returns interpretations of this form.
-/

namespace Cedar.SymCC

open Cedar.Spec
open Cedar.Data


structure UDF where -- unary defined function
  arg : TermType
  out : TermType
  table : Map Term Term
  default : Term

deriving instance Repr, DecidableEq, Inhabited for UDF

inductive UnaryFunction : Type where
  | uuf : UUF → UnaryFunction
  | udf : UDF → UnaryFunction

def UnaryFunction.argType : UnaryFunction → TermType
  | .uuf f => f.arg
  | .udf f => f.arg

def UnaryFunction.outType : UnaryFunction → TermType
  | .uuf f => f.out
  | .udf f => f.out

def UnaryFunction.isUUF : UnaryFunction → Bool
  | .uuf _ => true
  | .udf _ => false

def UnaryFunction.isUDF : UnaryFunction → Bool
  | .udf _ => true
  | .uuf _ => false

def UDF.isLiteral (f : UDF) : Bool :=
  f.default.isLiteral &&
  f.table.toList.all λ (tᵢ, tₒ) => tᵢ.isLiteral && tₒ.isLiteral

def UnaryFunction.isLiteral : UnaryFunction → Bool
  | .udf f => f.isLiteral
  | .uuf _ => false

deriving instance Repr, DecidableEq, Inhabited for UnaryFunction


end Cedar.SymCC
