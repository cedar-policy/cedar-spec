/-
 Copyright Cedar Contributors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-/

import Cedar.SymCC
import Cedar.SymCCOpt.CompiledPolicies
import Cedar.SymCCOpt.Extractor
import Cedar.SymCCOpt.Verifier
import Cedar.Validation.Validator

/-! This file contains the top-level interface to optimized SymCC. -/

namespace Cedar.SymCC

open Cedar.Spec

----- Slow verification checks that extract models -----

/--
Given compiled policies `cpss` and some `asserts`, calls the SMT solver (if
necessary) on an SMTLib encoding of `asserts` and returns `none` if the result
is unsatisfiable. Otherwise returns `some env` containing a counterexample
environment such that evaluating `cpss` in `env` violates the property verified
by `asserts`.

The `asserts` are expected to be well-formed with respect to the `εnv` which
`cpss` where compiled for, according to `Cedar.SymCC.Term.WellFormed`.
(Caller guarantees that all of the `cpss` were compiled for the same `εnv`.)
They must encode a property of policies `pc`.
Specifically, for each term `t ∈ asserts`, there must be a set of expressions
`xs` such that each `x ∈ xs` is a subexpression of `p ∈ ps`, where `ps` are the
(post-typecheck) policies that were compiled to `cpss`, and the meaning of `t` is
a function of the meaning of `xs`. This ensures that findings generated by
`solve` are sound and complete.
-/
def satAssertsOpt? (cpss : List CompiledPolicies) (asserts : Asserts) : SolverM (Option Env) := do
  match cpss with
  | [] => throw (IO.userError s!"satAssertsOpt? called with empty list of policies")
  | cps :: _ =>
  match ← checkSatAsserts asserts cps.εnv with
  | .none   => pure none
  | .some I =>
    match extractOpt? cpss I with
    | .some env => pure (some env)
    | .none     => throw (IO.userError s!"Extraction failed.")

/--
Returns `none` iff `p` does not error on any well-formed input in the `εnv` it
was compiled for.
Otherwise returns an input `some env` on which `p` errors.
-/
def neverErrorsOpt? (p : CompiledPolicy) : SolverM (Option Env) :=
  satAssertsOpt? [.policy p] (verifyNeverErrorsOpt p)

/--
Returns `none` iff `p` matches all well-formed inputs in `εnv`. That is,
if `p` is a `permit` policy, it allows all inputs in `εnv`, or if `p` is a
`forbid` policy, it denies all inputs in `εnv`.
Otherwise returns an input `some env` that is not-matched by `p`.

Compare with `alwaysAllowsOpt?`, which takes a policyset (which could consist of a
single policy, or more) and determines whether it _allows_ all well-formed
inputs in an `εnv`. This function differs from `alwaysAllowsOpt` on a singleton
policyset in how it treats `forbid` policies -- while `alwaysAllowsOpt` trivially
doesn't hold for any policyset containing only `forbid` policies,
`alwaysMatchesOpt` does hold if the `forbid` policy explicitly denies all inputs in
the `εnv`.
-/
def alwaysMatchesOpt? (p : CompiledPolicy) : SolverM (Option Env) :=
  satAssertsOpt? [.policy p] (verifyAlwaysMatchesOpt p)

/--
Returns `none` iff `p` matches no well-formed inputs in `εnv`.
Otherwise returns an input `some env` that is matched by `p`.

Compare with `alwaysDeniesOpt`, which takes a policyset (which could consist of a
single policy, or more) and determines whether it _denies_ all well-formed
inputs in an `εnv`. This function differs from `alwaysDeniesOpt` on a singleton
policyset in how it treats `forbid` policies -- while `alwaysDeniesOpt` trivially
holds for any policyset containing only `forbid` policies, `neverMatchesOpt` only
holds if the `forbid` policy explicitly denies no inputs in the `εnv`.
-/
def neverMatchesOpt? (p : CompiledPolicy) : SolverM (Option Env) :=
  satAssertsOpt? [.policy p] (verifyNeverMatchesOpt p)

/--
Returns `none` iff `p₁` and `p₂` match exactly the same set of well-formed
inputs in the `εnv` they were compiled for.
(Caller guarantees that `p₁` and `p₂` were compiled for the same `εnv`.)
Otherwise returns an input `some env` on which `p₁` and `p₂`
have different matching behavior (one matches and the other does not).

Compare with `equivalentOpt?`, which takes two policysets (which could consist of a
single policy, or more) and determines whether the _authorization behavior_ of
those policysets is equivalent for well-formed inputs in `εnv`. This function
differs from `equivalentOpt?` on singleton policysets in how it treats `forbid`
policies -- while `equivalentOpt?` trivially holds for any pair of `forbid` policies
(as they both always-deny), `matchesEquivalentOpt?` only holds if the two policies
match exactly the same set of inputs. Also, a nontrivial `permit` and nontrivial
`forbid` policy can be `matchesEquivalentOpt?`, but can never be `equivalentOpt?`.
-/
def matchesEquivalentOpt? (p₁ p₂ : CompiledPolicy) : SolverM (Option Env) :=
  satAssertsOpt? [.policy p₁, .policy p₂] (verifyMatchesEquivalentOpt p₁ p₂)

/--
Returns `none` iff `p₁` matching implies that `p₂` matches, for every
well-formed input in the `εnv` they were compiled for.
(Caller guarantees that `p₁` and `p₂` were compiled for the same `εnv`.)
That is, for every request where `p₁` matches, `p₂` also matches.
Otherwise returns an input `some env` that is matched by `p₁` but
not-matched by `p₂`.

Compare with `impliesOpt?`, which takes two policysets (which could consist of a
single policy, or more) and determines whether the _authorization decision_ of
the first implies that of the second. This function differs from `impliesOpt?` on
singleton policysets in how it treats `forbid` policies -- while for `impliesOpt?`,
any `forbid` policy trivially implies any `permit` policy (as always-deny always
implies any policy), for `matchesImpliesOpt?`, a `forbid` policy may or may not
imply a `permit` policy, and a `permit` policy may or may not imply a `forbid`
policy.
-/
def matchesImpliesOpt? (p₁ p₂ : CompiledPolicy) : SolverM (Option Env) :=
  satAssertsOpt? [.policy p₁, .policy p₂] (verifyMatchesImpliesOpt p₁ p₂)

/--
Returns `none` iff there is no well-formed input in the `εnv` they were compiled
for that is matched by both `p₁` and `p₂`.
(Caller guarantees that `p₁` and `p₂` were compiled for the same `εnv`.)
Otherwise returns an input `some env` that is matched by both `p₁` and `p₂`.
This checks that the sets of inputs matched by `p₁` and `p₂` are disjoint.

Compare with `disjointOpt?`, which takes two policysets (which could consist of a
single policy, or more) and determines whether the _authorization behavior_ of
those policysets are disjoint. This function differs from `disjointOpt?` on
singleton policysets in how it treats `forbid` policies -- while for
`disjointOpt?`, any `forbid` policy is trivially disjoint from any other policy (as
it allows nothing), `matchesDisjointOpt?` considers whether the `forbid` policy may
_match_ (rather than _allow_) any input that is matched by the other policy.
-/
def matchesDisjointOpt? (p₁ p₂ : CompiledPolicy) : SolverM (Option Env) :=
  satAssertsOpt? [.policy p₁, .policy p₂] (verifyMatchesDisjointOpt p₁ p₂)

/--
Returns `none` iff the authorization decision of `ps₁` implies that of `ps₂` for
every well-formed input in the `εnv` that the policysets were compiled for.
(Caller guarantees that `ps₁` and `ps₂` were compiled for the same `εnv`.)
That is, every input allowed by `ps₁` is allowed by `ps₂`; `ps₂` is either more
permissive than, or equivalent to, `ps₁`.
Otherwise returns an input `some env` that is allowed by `ps₁` but denied by `ps₂`.
-/
def impliesOpt? (ps₁ ps₂ : CompiledPolicySet) : SolverM (Option Env) :=
  satAssertsOpt? [.pset ps₁, .pset ps₂] (verifyImpliesOpt ps₁ ps₂)

/--
Returns `none` iff `ps` allows all well-formed inputs in the `εnv` it was
compiled for.
Otherwise returns an input `some env` that is denied by `ps`.
-/
def alwaysAllowsOpt? (ps : CompiledPolicySet) : SolverM (Option Env) :=
  satAssertsOpt? [.pset ps] (verifyAlwaysAllowsOpt ps)

/--
Returns `none` iff `ps` denies all well-formed inputs in the `εnv` it was
compiled for.
Otherwise returns an input `some env` that is allowed by `ps`.
-/
def alwaysDeniesOpt? (ps : CompiledPolicySet) : SolverM (Option Env) :=
  satAssertsOpt? [.pset ps] (verifyAlwaysDeniesOpt ps)

/--
Returns `none` iff `ps₁` and `ps₂` produce the same authorization decision on
all well-formed inputs in the `εnv` that the policysets were compiled for.
(Caller guarantees that `ps₁` and `ps₂` were compiled for the same `εnv`.)
Otherwise returns an input `some env` on which `ps₁` and `ps₂` produce different
authorization decisions.
-/
def equivalentOpt? (ps₁ ps₂ : CompiledPolicySet) : SolverM (Option Env) :=
  satAssertsOpt? [.pset ps₁, .pset ps₂] (verifyEquivalentOpt ps₁ ps₂)

/--
Returns `none` iff there is no well-formed input in `εnv` that the policysets were
compiled for, that is allowed by both `ps₁` and `ps₂`.
(Caller guarantees that `ps₁` and `ps₂` were compiled for the same `εnv`.)
Otherwise returns an input `some env` that is allowed by both `ps₁` and `ps₂`.
This checks that the authorization semantics of `ps₁` and `ps₂` are disjoint.
-/
def disjointOpt? (ps₁ ps₂ : CompiledPolicySet) : SolverM (Option Env) :=
  satAssertsOpt? [.pset ps₁, .pset ps₂] (verifyDisjointOpt ps₁ ps₂)

----- Faster verification checks that don't extract models -----

/--
Returns true iff `p` does not error on any well-formed input in the `εnv` it was
compiled for.
-/
def checkNeverErrorsOpt (p : CompiledPolicy) : SolverM Bool :=
  checkUnsatAsserts (verifyNeverErrorsOpt p) p.εnv

/--
Returns `none` iff `p` matches all well-formed inputs in `εnv`. That is,
if `p` is a `permit` policy, it allows all inputs in `εnv`, or if `p` is a
`forbid` policy, it denies all inputs in `εnv`.
Otherwise returns an input `some env` that is not-matched by `p`.

Compare with `checkAlwaysAllowsOpt`, which takes a policyset (which could
consist of a single policy, or more) and determines whether it _allows_ all
well-formed inputs in an `εnv`. This function differs from
`checkAlwaysAllowsOpt` on a singleton policyset in how it treats `forbid`
policies -- while `checkAlwaysAllowsOpt` trivially doesn't hold for any
policyset containing only `forbid` policies, `checkAlwaysMatchesOpt` does hold
if the `forbid` policy explicitly denies all inputs in the `εnv`.
-/
def checkAlwaysMatchesOpt (p : CompiledPolicy) : SolverM Bool :=
  checkUnsatAsserts (verifyAlwaysMatchesOpt p) p.εnv

/--
Returns `none` iff `p` matches no well-formed inputs in `εnv`.
Otherwise returns an input `some env` that is matched by `p`.

Compare with `checkAlwaysDeniesOpt`, which takes a policyset (which could
consist of a single policy, or more) and determines whether it _denies_ all
well-formed inputs in an `εnv`. This function differs from
`checkAlwaysDeniesOpt` on a singleton policyset in how it treats `forbid`
policies -- while `checkAlwaysDeniesOpt` trivially holds for any policyset
containing only `forbid` policies, `checkNeverMatchesOpt` only holds if the
`forbid` policy explicitly denies no inputs in the `εnv`.
-/
def checkNeverMatchesOpt (p : CompiledPolicy) : SolverM Bool :=
  checkUnsatAsserts (verifyNeverMatchesOpt p) p.εnv

/--
Returns true iff `p₁` and `p₂` match exactly the same set of well-formed
inputs in the `εnv` they were compiled for.
(Caller guarantees that `p₁` and `p₂` were compiled for the same `εnv`.)

Compare with `checkEquivalentOpt`, which takes two policysets (which could consist of a
single policy, or more) and determines whether the _authorization behavior_ of
those policysets is equivalent for well-formed inputs in `εnv`. This function
differs from `checkEquivalentOpt` on singleton policysets in how it treats `forbid`
policies -- while `checkEquivalentOpt` trivially holds for any pair of `forbid` policies
(as they both always-deny), `checkMatchesEquivalentOpt` only holds if the two policies
match exactly the same set of inputs. Also, a nontrivial `permit` and nontrivial
`forbid` policy can be `checkMatchesEquivalentOpt`, but can never be `checkEquivalentOpt`.
-/
def checkMatchesEquivalentOpt (p₁ p₂ : CompiledPolicy) : SolverM Bool :=
  checkUnsatAsserts (verifyMatchesEquivalentOpt p₁ p₂) p₁.εnv

/--
Returns true iff `p₁` matching implies that `p₂` matches, for every
well-formed input in the `εnv` they were compiled for.
(Caller guarantees that `p₁` and `p₂` were compiled for the same `εnv`.)
That is, for every request where `p₁` matches, `p₂` also matches.

Compare with `checkImpliesOpt`, which takes two policysets (which could consist of
a single policy, or more) and determines whether the _authorization decision_ of
the first implies that of the second. This function differs from `checkImpliesOpt`
on singleton policysets in how it treats `forbid` policies -- while for
`checkImpliesOpt`, any `forbid` policy trivially implies any `permit` policy (as
always-deny always implies any policy), for `checkMatchesImpliesOpt`, a `forbid`
policy may or may not imply a `permit` policy, and a `permit` policy may or may
not imply a `forbid` policy.
-/
def checkMatchesImpliesOpt (p₁ p₂ : CompiledPolicy) : SolverM Bool :=
  checkUnsatAsserts (verifyMatchesImpliesOpt p₁ p₂) p₁.εnv

/--
Returns true iff there is no well-formed input in the `εnv` they were compiled
for that is matched by both `p₁` and `p₂`.
(Caller guarantees that `p₁` and `p₂` were compiled for the same `εnv`.)
This checks that the sets of inputs matched by `p₁` and `p₂` are disjoint.

Compare with `checkDisjointOpt`, which takes two policysets (which could consist of
a single policy, or more) and determines whether the _authorization behavior_ of
those policysets are disjoint. This function differs from `checkDisjointOpt` on
singleton policysets in how it treats `forbid` policies -- while for
`checkDisjointOpt`, any `forbid` policy is trivially disjoint from any other policy
(as it allows nothing), `checkMatchesDisjointOpt` considers whether the `forbid`
policy may _match_ (rather than _allow_) any input that is matched by the other
policy.
-/
def checkMatchesDisjointOpt (p₁ p₂ : CompiledPolicy) : SolverM Bool :=
  checkUnsatAsserts (verifyMatchesDisjointOpt p₁ p₂) p₁.εnv

/--
Returns true iff the authorization decision of `ps₁` implies that of `ps₂` for
every well-formed input in `εnv` that the policysets were compiled for.
(Caller guarantees that `ps₁` and `ps₂` were compiled for the same `εnv`.)
That is, every input allowed by `ps₁` is allowed by `ps₂`; `ps₂` is either more
permissive than, or equivalent to, `ps₁`.
-/
def checkImpliesOpt (ps₁ ps₂ : CompiledPolicySet) : SolverM Bool :=
  checkUnsatAsserts (verifyImpliesOpt ps₁ ps₂) ps₁.εnv

/--
Returns true iff `ps` allows all well-formed inputs in the `εnv` it was compiled
for.
-/
def checkAlwaysAllowsOpt (ps : CompiledPolicySet) : SolverM Bool :=
  checkUnsatAsserts (verifyAlwaysAllowsOpt ps) ps.εnv

/--
Returns true iff `ps` denies all well-formed inputs in the `εnv` it was compiled
for.
-/
def checkAlwaysDeniesOpt (ps : CompiledPolicySet) : SolverM Bool :=
  checkUnsatAsserts (verifyAlwaysDeniesOpt ps) ps.εnv

/--
Returns true iff `ps₁` and `ps₂` produce the same authorization decision on all
well-formed inputs in the `εnv` that the policysets were compiled for.
-/
def checkEquivalentOpt (ps₁ ps₂ : CompiledPolicySet) : SolverM Bool :=
  checkUnsatAsserts (verifyEquivalentOpt ps₁ ps₂) ps₁.εnv

/--
Returns true iff there is no well-formed input in `εnv` that is allowed by both
`ps₁` and `ps₂`.
(Caller guarantees that `ps₁` and `ps₂` were compiled for the same `εnv`.)
This checks that the authorization semantics of `ps₁` and `ps₂` are disjoint. If
this query is satisfiable, then there is at least one well-formed input that is
allowed by both `ps₁` and `ps₂`.
-/
def checkDisjointOpt (ps₁ ps₂ : CompiledPolicySet) : SolverM Bool :=
  checkUnsatAsserts (verifyDisjointOpt ps₁ ps₂) ps₁.εnv

end Cedar.SymCC
