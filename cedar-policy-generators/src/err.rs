/*
 * Copyright Cedar Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

use cedar_policy_core::ast;
use thiserror::Error;

/// Our Error type, which carries somewhat more information than
/// `arbitrary::Error`, for the purposes of debugging and metrics
#[derive(Debug, Error)]
pub enum Error {
    /// Like `NotEnoughData` in `arbitrary::Error`, this represents that we ran
    /// out of bytes in the `Unstructured`
    #[error("not enough data")]
    NotEnoughData,
    /// Like `EmptyChoose` in `arbitrary::Error`, this represents that we tried
    /// to `.choose()` (or equivalent) on an empty slice
    #[error("while {doing_what}: `.choose()` (or equivalent) on an empty slice")]
    EmptyChoose {
        /// short string describing what we were doing when this happened
        doing_what: String,
    },
    /// Tried to generate an expression deeper than allowed, and couldn't
    /// recover by putting some depth-0 expression in the leaf
    #[error("recursion deeper than allowed, and we couldn't recover")]
    TooDeep,
    /// Generated schema ended up with no valid principal types, no valid
    /// resource types, or both
    #[error("no valid principal types, or, no valid resource types")]
    NoValidPrincipalOrResourceTypes,
    /// Tried to generate something with an extension type, but extension types
    /// were disabled in settings
    #[error(
        "tried to generate something with an extension type, but extension types were disabled"
    )]
    ExtensionsDisabled,
    /// Tried to generate something using the `like` operator, but the `like`
    /// operator was disabled in settings
    #[error("tried to generate something using the `like` operator, but the `like` operator was disabled")]
    LikeDisabled,
    /// `IncorrectFormat` error that was generated by the `arbitrary` crate directly.
    /// We try to maintain the invariant that we don't generate these ourselves,
    /// preferring the more specific errors above
    #[error("while {doing_what}: incorrect format")]
    IncorrectFormat {
        /// short string describing what we were doing when this happened
        doing_what: String,
    },
    /// An error that occurs attempting to convert a hierarchy into an entities structure,
    /// or more generally an Entity as represented in this crate, into an `ast::Entity`
    #[error("{0}")]
    EntitiesError(String),
    /// An error that occurs building an `ast::Context`, possibly due to errors
    /// in extension constructors.
    #[error(transparent)]
    ContextError(#[from] ast::ContextCreationError),
    /// Error thrown by the `cedar_policy_validator` crate while processing a
    /// user-provided schema.
    #[error(transparent)]
    SchemaError(#[from] cedar_policy_validator::SchemaError),
    /// Error generated by the `arbitrary` crate, other than the three in
    /// `arbitrary::Error` as of this writing. This is necessary because
    /// `arbitrary::Error` is marked non-exhaustive. We don't generate these
    /// ourselves.
    #[error(transparent)]
    OtherArbitrary(arbitrary::Error),
    /// Error thrown when the generator produces a schema that has too many
    /// valid request environments
    #[error("Too many request environments: {} vs upper bound {}", .0 , crate::schema::Schema::PER_ACTION_REQUEST_ENV_LIMIT)]
    TooManyReqEnvs(usize),
}

/// Type alias for convenience
pub type Result<T> = std::result::Result<T, Error>;

impl From<Error> for arbitrary::Error {
    fn from(e: Error) -> arbitrary::Error {
        match e {
            Error::NotEnoughData => arbitrary::Error::NotEnoughData,
            Error::EmptyChoose { .. } => arbitrary::Error::EmptyChoose,
            Error::TooDeep => arbitrary::Error::IncorrectFormat,
            Error::NoValidPrincipalOrResourceTypes => arbitrary::Error::IncorrectFormat,
            Error::ExtensionsDisabled => arbitrary::Error::IncorrectFormat,
            Error::LikeDisabled => arbitrary::Error::IncorrectFormat,
            Error::EntitiesError(_) => arbitrary::Error::IncorrectFormat,
            Error::IncorrectFormat { .. } => arbitrary::Error::IncorrectFormat,
            Error::ContextError(_) => arbitrary::Error::IncorrectFormat,
            Error::SchemaError(_) => arbitrary::Error::IncorrectFormat,
            Error::OtherArbitrary(e) => e,
            Error::TooManyReqEnvs(_) => arbitrary::Error::IncorrectFormat,
        }
    }
}

impl From<arbitrary::Error> for Error {
    fn from(e: arbitrary::Error) -> Error {
        match e {
            arbitrary::Error::NotEnoughData => Error::NotEnoughData,
            arbitrary::Error::EmptyChoose => Error::EmptyChoose {
                doing_what: String::new(),
            },
            arbitrary::Error::IncorrectFormat => Error::IncorrectFormat {
                doing_what: String::new(),
            },
            e => Error::OtherArbitrary(e),
        }
    }
}

/// Apply this to an `arbitrary::Error` to get an `Error` with a more
/// informative `doing_what` in the EmptyChoose or IncorrectFormat cases
pub fn while_doing(what: String, e: arbitrary::Error) -> Error {
    match e {
        arbitrary::Error::EmptyChoose => Error::EmptyChoose { doing_what: what },
        arbitrary::Error::IncorrectFormat => Error::IncorrectFormat { doing_what: what },
        e => e.into(),
    }
}
